# pyRootHair

Welcome to the pyRootHair github repository! 

Here, you will find all necessary information on how to install and setup pyRootHair, detailed information about the various pipelines and options available, and an in-depth tutorial on how pyRootHair works.

Please do not hesitate to submit a pull-request, or get in touch via [email](ian.tsang@niab.com) if you have any questions, suggestions or concerns!


## Installation instructions

`mkdir ~/pyroothair`  
`git clone https://github.com/iantsang779/pyRootHair`  
`cd pyroothair`  

## How to use pyRootHair

WIP.

## An in-depth dive into the pyRootHair workflow

This section is for users that are curious about how pyRootHair extracts traits from a given input image. In essence, this is a step by step process of the functions and logic within the source code. For this demonstration, I will be using the demo image `demo/karim_demo.png` and the corresponding binary segmentation mask `demo/karim_demo_mask.png`. 

### Loading the necessary libraries

First, Iimport the required libraries:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import imageio.v3 as iio

from skimage.measure import label, regionprops
from skimage.morphology import skeletonize
from skimage.transform import rotate, warp, PiecewiseAffineTransform
from scipy.ndimage import convolve
from scipy.spatial.distance import euclidean
from scipy.interpolate import CubicSpline
from statsmodels.nonparametric.smoothers_lowess import lowess
```

For reference, the following versions were used at the time of writing this tutorial:

- python: 3.12.3
- numpy: 2.0.2
- pandas: 2.2.3
- matplotlib: 3.9.0
- imageiov3: 2.36.1
- scikit-image: 0.24.0
- scipy: 1.14.1
- statsmodels: 0.14.4

### Viewing the demo image and binary mask

Here, Ifirst read in the raw image, and corresponding binary mask. The mask was generated by the integrated nnUNet segmentation model within pyRootHair.  

Since the mask is an array of [0, 1, 2], it will show up as a black image.   

This image was specifically chosen for a few reasons:

- Noise in the background (agar fragments)
- Root is inherently curved and not directly oriented downwards
- Presence of non-primary root sections

```python
image = iio.imread('demo/karim_demo.png')
mask = iio.imread('demo/karim_demo_mask.png')

fig, ax = plt.subplots(ncols=2, figsize=(15,10))
ax[0].imshow(image)
ax[0].set_title('Raw Image')
ax[1].imshow(mask)
ax[1].set_title('Binary Mask')
```
![alt text](demo/raw_binary.png)

From now on, I will process the binary mask.

### Root extraction

First, I will extract just the root from the binary mask. This is needed to determine how to pre-process the mask, including rotation and subsequent straightening. 

All pixels with the class label '2' is considered part of the root, and stored in a new variable `root_mask`.

```python
root_mask = (mask == 2)

plt.imshow(root_mask)
```
![alt text](demo/init_root_mask.png)

Next, I define`clean_root_chunk()` and `extract_root()`. `clean_root_chunk()` cleans up each chunk of root (or root hair) by removing all but the largest component present. `extract_root()` labels the root, and runs `clean_root_chunk()` if more than one primary fragment is detected. By running these functions on the root binary mask, only the largest root (the primary root Iare interested in) is retained.

`clean_root_chunk()` is run if more than 1 root section is detected in the root mask. The function returns the cleaned root, and a count of the number of objects in the cleaned root mask.

Cleaning the mask is extremely important to calculate accurate parameters for mask manipulation, which will soon be evident.

```python

def clean_root_chunk(mask: 'NDArray') -> tuple[NDArray, list]:
    """
    Clean up each small section of the root mask by removing all but the largest area present
    """
    root_section_labeled, num_labels = label(mask, connectivity=2, return_num=True) # label the root mask
    
    if num_labels > 0:
        root_section_measured = regionprops(root_section_labeled) # measure the root section 
        max_label = max(root_section_measured, key=lambda x: x.area).label # get the label associated with the largest area in the measured section
        
        # mask out the smaller sections, retaining only the largest section
        clean_root_mask = root_section_labeled == max_label 
        root_section_labeled, _ = label(clean_root_mask, connectivity=2, return_num=True) # re label root 
        root_section_measured = regionprops(root_section_labeled) # re measure root section

        return root_section_labeled, root_section_measured

def extract_root(root_mask: 'NDArray)
    root_labeled_clean, count = label(root_mask, connectivity=2, return_num=True)

    if count > 1:
        root_labeled_cleaned, count = clean_root_chunk(root_mask)

    return root_labeled_cleaned

root_labeled_cleaned = extract_root()
```
Here is the cleaned root mask:

```python
plt.imshow(root_labeled_cleaned)
```
![alt text](demo/cleaned_root_mask.png)

### Skeletonizing the main root

Next, the main root is skeletonized, and all the co-ordinates of the skeleton are returned.

```python
skeleton = skeletonize(root_labeled_cleaned)

skeleton_y, skeleton_x = np.nonzero(skeleton)

plt.imshow(skeleton)
```
![alt text](demo/skeleton.png)

In this case, the skeletonized root is a near perfect representation of the midline of the initial root. However, in the even of poor root segmentation, the skeletonized root will be a poor approximation of the root midline. 

As such, the midline can be approximated by first fitting a spline to all co-ordinates of the skeleton:

```python
t_range  = np.arange(len(skeleton_x))
x_spline = CubicSpline(t_range, skeleton_x)(t_range)
y_spline = CubicSpline(t_range, skeleton_y)(t_range)
merged_spline = np.array(list(zip(x_spline, y_spline)))
```
The start and end points of the skeleton are calculated from the spline:

```python
skeleton_start = int(min(y_spline))
skeleton_end = int(max(y_spline))
```
Next, the midline is approximated from the spline via a sliding window to calculate the median of each bin:

```python
med_x, med_y = [], []
        
bin_size = 100
for start in range(start, end, bin_size):
    end = start + bin_size
    bin_y_val = [x[1] for x in merged_spline if start <= x[1] <= end]
    bin_x_val = [x[0] for x in merged_spline if start <= x[1] <= end]
    
    med_y.append(np.median(bin_y_val)) 
    med_x.append(np.median(bin_x_val))

```
Here is a visualization of the spline mapped to the skeleton:

```python
fig, ax = plt.subplots()
plt.plot(merged_spline[:,0], merged_spline[:,1], 'y.')
ax.yaxis.set_inverted(True)
```
![alt text](/demo/spline.png)

### Rotating the root

Now that Ihave the median co-ordinates to approximate the root midline, Ican calculate the angle required to rotate the root such that the root tip/end of the root in frame is pointing downwards.

Here, I calculate the change in y and change in x of the endpoints of the root midline:
```python
dy = max(med_y) - min(med_y)
dx = med_x[0] - med_x[-1]
```

Next, I calculate the angle to rotate the root relative to the vertical, and rotate the image.  
The rotated image is resized with `resize=True` to preserve resolution of the original input image.

```python
angle = np.rad2deg(np.arctan(dx/dy))
    
rotated_mask = rotate(root_labeled_cleaned, angle, preserve_range=True, resize=True, mode='constant')

plt.imshow(rotated_mask)

```
![alt text](demo/rotated_mask.png)

### Repeat of previous steps

Now I have a rotated mask of the original image, the previous steps are repeated:
- extract the root
- clean the root 
- skeletonize the root 
- approximate the midline of the rotated root skeleton

All repeated steps are illustrated here for convenience:

```python
### Extract root

rotated_root_mask = (rotated_mask == 2)

rotated_root_labeled_cleaned = extract_root(rotated_root_mask)

### Skeletonize root
skeleton_rotated = skeletonize(rotated_root_labeled_cleaned)

skeleton_y_rot, skeleton_x_rot = np.nonzero(skeleton_rotated)

### Map points to skeleton
t_range_rot  = np.arange(len(skeleton_x_rot))
x_spline_rot = CubicSpline(t_range_rot, skeleton_x_rot)(t_range_rot)
y_spline_rot = CubicSpline(t_range_rot, skeleton_y_rot)(t_range_rot)

merged_spline_rot = np.array(list(zip(x_spline_rot, y_spline_rot)))
skeleton_start_rot = int(min(y_spline_rot))
skeleton_end_rot = int(max(y_spline_rot))

### Sliding window to approximate midline 
med_x_rot, med_y_rot = [], []
bin_size = 100

for start in range(skeleton_start_rot, skeleton_end_rot, bin_size):
    end = start + bin_size
    bin_y_val_rot = [x[1] for x in merged_spline_rot if start <= x[1] <= end]
    bin_x_val_rot = [x[0] for x in merged_spline_rot if start <= x[1] <= end]
    
    med_y_rot.append(np.median(bin_y_val_rot)) 
    med_x_rot.append(np.median(bin_x_val_rot))
```

As you can see, the code is exactly the same as previously described, just with a few variable changes. This chunk calculates the approximated midline of the rotated root skeleton.

### Straightening the root

To obtain accurate root hair measurements, the curved root needs to be straightened as much as possible. The root will be straightened by warping. 

First, I need to add endpoints to the image to ensure all of the image is warped. Here, I define the end and second end points of each end of the rotated root skeleton:

```python
points = np.array(list(zip(med_x_rot, med_y_rot)))

first_point = points[0] 
second_point = points[1]

last_point = points[-1]
seclast_point = points[-2]
```

Next, I generate new endpoints beyond the image boundary, based on euclidean distances between the previous points. This section is heavily inspired the following stackoverflow answer: https://stackoverflow.com/questions/73614379/how-do-i-use-piecewise-af%EF%AC%81ne-transformation-to-straighten-curved-text-line-cont

```python
def generate_endpoints(pointA: list, pointB: list, length: int) -> tuple[float, float]:
    """
    Generate new end points
    """
    len_pApB = euclidean(pointA, pointB)
    n_x = pointA[0] + ((pointA[0]-pointB[0]) / len_pApB*length)
    n_y = pointA[1] + ((pointA[1]-pointB[1]) / len_pApB*length)

    return n_x, n_y

first_x, first_y = generate_endpoints(first_point, second_point, 100)
last_x, last_y = generate_endpoints(last_point, seclast_point, 100)

# Add new end points to the beginning/end of points array
points = np.vstack([[first_x, first_y], points])
points = np.vstack([points,[last_x, last_y]])

plt.imshow(rotated_root_labeled_cleaned)
plt.scatter(points[:,0], points[:,1], s=10, marker='x')
plt.scatter(points[:,0][0], points[:,1][0], color='red', s=20)
plt.scatter(points[:,0][0], points[:,1][-1], color='red', s=20)
```
Here, this plot illustrates the addition of new endpoints (red circles) at the end of all the midline co-ordinates of the rotated root mask (blue `x`s).

![alt text](demo/endpoints.png)

The red endpoints ensure all y-pixels will be captured in the warping. Next, I create a new set of vertical points, originating from the newly created first co-ordinate of the root skeleton midline (top red circle). This vertical line defines the destination for transformation, mapping the curved blue `x`s to the orange `*`s:

```python
dist = [euclidean(x,y) for x,y in zip(points, points[1:])] # euclidean distance between each midline point
dist_lookup = list(zip(points[:-1],dist))

old_p = points[0]
new_p = old_p + (0, dist[0])
new_points = [old_p, new_p,]

# create new array to store co-ordinates of new points 
for x in dist_lookup[1:]:
    last_point = new_points[-1]
    _, dist = x

    length = euclidean(old_p, last_point)
    new_y_val = last_point[1] + ((last_point[1] - old_p[1]) / length*dist)
    new_points.append([old_p[0], new_y_val]) 

new_points = np.array(new_points)

plt.imshow(rotated_root_labeled_cleaned)
plt.scatter(points[:,0], points[:,1], s=10, marker='x')
plt.scatter(new_points[:,0], new_points[:,1], s=10, marker='*', color='orange')
plt.scatter(points[:,0][0], points[:,1][0], color='red', s=20)
plt.scatter(points[:,0][0], points[:,1][-1], color='red', s=20)
```

![alt text](demo/endpoints_vert.png)

Afterwards, I generate old and new buffer co-ordinates to pad around the image, defining the x-region to capture during warping. The old buffer (blue) co-ordinates on either side are parallel to the original root curvature, while the new buffer (orange) co-ordinates are straight, parallel to the new vertical line originating below the first red point.

```python
padding = rotated_mask.shape[1] 

old_buffer_coords = np.vstack([points+[padding,0], points+[-padding,0]])
new_buffer_coords = np.vstack([new_points+[padding,0], new_points+[-padding,0]])

plt.imshow(rotated_root_labeled_cleaned)
plt.scatter(points[:,0], points[:,1], s=10, marker='x', color='blue')
plt.scatter(new_points[:,0], new_points[:,1], s=15, marker='*', color='orange')
plt.scatter(old_buffer_coords[:,0], old_buffer_coords[:,1], s=15, marker='x', color='blue')
plt.scatter(new_buffer_coords[:,0], new_buffer_coords[:,1], s=15, marker='*', color='orange')
plt.scatter(points[:,0][0], points[:,1][0], color='red', s=20)
plt.scatter(points[:,0][0], points[:,1][-1], color='red', s=20)
```
 
![alt text](demo/warp_points.png)

Finally, I can apply a piecewise affine transformation, which maps all co-ordinates in the image from the regions bound by the blue `x`s to the orange `*`s:

```python

tform = PiecewiseAffineTransform()
tform.estimate(new_buffer_coords,old_buffer_coords)

straight_mask = warp(rotated_mask, tform, mode='symmetric')
```
The original binary mask is now straightened:

```python 
plt.imshow(straight_mask)
```
![alt text](demo/straight_mask.png)

### Splitting root hair segments

With the straightened binary mask, I can now attempt to locate the root tip/endpoint of the root in frame. 

During the warping process, some pixels may be lost, so when re-extracting the root from the binary mask, I reduce the mask criteria from 2 to 1.5:

```python
final_root_mask = (straight_mask > 1.5)
```

Now, I clean up the root mask, and calculate the lowest y co-ordinate of the root, and the image height. If the lowest root y co-ordinate is smaller than the image height, then either the root tip, or the end of the root can be detected in frame:

```python
final_root_labeled, final_root_count = label(final_root_mask, connectivity=2, return_num=True)

if final_root_count > 1: # if more than 1 root is present    
    final_root_labeled, final_root_count = clean_root_chunk(final_root_labeled)


root_measured = regionprops(final_root_labeled) # measure cleaned root
coords = [i.coords for i in root_measured][0] # get all coords of masked cleaned root
max_root_y_coord = max(coords[:,0]) # get max y-coord of cleaned root
image_height = straight_mask.shape[0] # get height of the image

if image_height - max_root_y_coord > 1: # if > 1 px difference between image height and max y of root
    found_tip = True 
```

If found_tip is True, I can locate the root tip using kernel convolution along the skeletonized straight root mask. The kernel will return values of 3 for each edge pixel in the skeleton, as each edge pixel will only have 1 neighbour. 

Next, I obtain a list of all the calculated endpoints from convolution, and the root tip/end of the root is set as the last value of the endpoints list. The top of the root in frame is set as the first value of the endpoints list:

```python
if found_tip:
    final_skeleton = skeletonize(final_root_labeled)
    kernel = np.array([[1,1,1], 
                        [1,2,1],  # each pixel in sliding window has value of 2 (2 x 1), while neighboring pixels have a value of 1 
                        [1,1,1]]) # define kernel that slides over each pixel in the rotated root skeleton.


    neighbours = convolve(final_skeleton.astype(int), kernel, mode='constant') # apply convolution to skeleton to find out which pixels have 1 neighbour
    endpoints = np.where(neighbours == 3) # edges only have 1 neighbour, so 2 + 1 = 3
    endpoints = list(zip(endpoints[0], endpoints[1])) # store results in paired list 
    root_tip = max(endpoints, key = lambda x: x[0]) # get coords where y-coord is max (bottom of root - assuming root growing downwards)
    root_start = min(endpoints, key=lambda x: x[0]) # coords of where root starts
    root_tip_y, root_tip_x = root_tip 
    root_start_y, root_start_x = root_start
```
I can visualize the root tip/end of root, and the start of the root overlayed on the straightened root skeleton:

```python
plt.imshow(final_skeleton)
plt.plot(root_tip_x, root_tip_y, 'yo')
plt.plot(root_start_x, root_start_y, 'g+')
```
![alt text](demo/root_start_stop.png)

Next, I extract out the root hair mask from the rotated binary mask, and clean out any non-primary root hair sections:

```python












I can now split the root hair segments around the root start, and root tip regions. This ensures the root hair mask will be separated into 2 distinct chunks - one for either side of the main root.

```




















