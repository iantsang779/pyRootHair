# pyRootHair

Welcome to the pyRootHair github repository! Here, you will find all necessary information on how to install and setup pyRootHair, detailed information about the various pipelines and options available, and an in-depth tutorial on how pyRootHair works.

Please do not hesitate to submit a pull-request, or get in touch via [email](ian.tsang@niab.com) if you have any questions, suggestions or concerns!


## Installation instructions

`mkdir ~/pyroothair`  
`git clone https://github.com/iantsang779/pyRootHair`  
`cd pyroothair`  

## How to use pyRootHair

WIP.

## An in-depth dive into the pyRootHair workflow

This section is for users that are curious about how pyRootHair extracts traits from a given input image. In essence, this is a step by step process of the functions and logic within the source code. For this demonstration, I will be using the demo image `karim_demo.png` and the corresponding binary segmentation mask `karim_demo_mask.png`.

### Loading the necessary libraries

First, we import the required libraries:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import imageio.v3 as iio

from skimage.measure import label, regionprops
from skimage.morphology import skeletonize
from skimage.transform import rotate, warp, PiecewiseAffineTransform
from scipy.ndimage import convolve
from scipy.spatial.distance import euclidean
from scipy.interpolate import CubicSpline
from statsmodels.nonparametric.smoothers_lowess import lowess
```

For reference, the following versions were used at the time of writing this tutorial:

- python: 3.12.3
- numpy: 2.0.2
- pandas: 2.2.3
- matplotlib: 3.9.0
- imageiov3: 2.36.1
- scikit-image: 0.24.0
- scipy: 1.14.1
- statsmodels: 0.14.4

### Viewing the demo image and binary mask

Here, we first read in the raw image, and corresponding binary mask. The mask was generated by the integrated nnUNet segmentation model within pyRootHair.  

Since the mask is an array of [0, 1, 2], it will show up as a black image.   

This image was specifically chosen for a few reasons:

- Noise in the background (agar fragments)
- Root is inherently curved and not directly oriented downwards
- Presence of non-primary root sections

```python
image = iio.imread('demo/karim_demo.png')
mask = iio.imread('demo/karim_demo_mask.png')

fig, ax = plt.subplots(ncols=2, figsize=(15,10))
ax[0].imshow(image)
ax[0].set_title('Raw Image')
ax[1].imshow(mask)
ax[1].set_title('Binary Mask')
```
![alt text](demo/raw_binary.png)

From now on, I will process the binary mask.

### Root extraction

First, I will extract just the root from the binary mask. This is needed to determine how to pre-process the mask, including rotation and subsequent straightening. 

All pixels with the class label '2' is considered part of the root, and stored in a new variable `root_mask`.

```python
root_mask = (mask == 2)

plt.imshow(root_mask)
```
![alt text](demo/init_root_mask.png)

Next, I label the root, and define a very helpful function `clean_root_chunk()`. This function cleans up each chunk of root (or root hair) by removing all but the largest component present. By running this function on the root binary mask, only the largest root (the primary root we are interested in) is retained.

`clean_root_chunk()` is run if more than 1 root section is detected in the root mask. The function returns the cleaned root, and a count of the number of objects in the cleaned root mask.

```python
root_labeled_clean, count = label(root_mask, connectivity=2, return_num=True)

def clean_root_chunk(mask: 'NDArray') -> tuple[NDArray, list]:
    """
    Clean up each small section of the root mask by removing all but the largest area present
    """
    root_section_labeled, num_labels = label(mask, connectivity=2, return_num=True) # label the root mask
    
    if num_labels > 0:
        root_section_measured = regionprops(root_section_labeled) # measure the root section 
        max_label = max(root_section_measured, key=lambda x: x.area).label # get the label associated with the largest area in the measured section
        
        # mask out the smaller sections, retaining only the largest section
        clean_root_mask = root_section_labeled == max_label 
        root_section_labeled, _ = label(clean_root_mask, connectivity=2, return_num=True) # re label root 
        root_section_measured = regionprops(root_section_labeled) # re measure root section

        return root_section_labeled, root_section_measured

if count > 1:
    root_labeled_cleaned, count = clean_root_chunk(root_mask)

```
We can see the cleaned root mask now.

```python
plt.imshow(root_labeled_cleaned)
```
![alt text](demo/cleaned_root_mask.png)

### Skeletonizing the main root

Next, the main root is skeletonized, and all the co-ordinates of the skeleton are returned.

```python
skeleton = skeletonize(root_labeled_cleaned)

skeleton_y, skeleton_x = np.nonzero(skeleton)

plt.imshow(skeleton)
```
![alt text](demo/skeleton.png)

In this case, the skeletonized root is a near perfect representation of the midline of the initial root. However, in the even of poor root segmentation, the skeletonized root will be a poor approximation of the root midline. 

As such, the midline can be approximated by first fitting a spline to all co-ordinates of the skeleton:

```python
t_range  = np.arange(len(skeleton_x))
x_spline = CubicSpline(t_range, skeleton_x)(t_range)
y_spline = CubicSpline(t_range, skeleton_y)(t_range)
merged_spline = np.array(list(zip(x_spline, y_spline)))
```
The start and end points of the skeleton are calculated from the spline:

```python
skeleton_start = int(min(y_spline))
skeleton_end = int(max(y_spline))
```
Next, the midline is approximated from the spline via a sliding window to calculate the median of each bin:

```python
med_x, med_y = [], []
        
bin_size = 100
for start in range(start, end, bin_size):
    end = start + bin_size
    bin_y_val = [x[1] for x in merged_spline if start <= x[1] <= end]
    bin_x_val = [x[0] for x in merged_spline if start <= x[1] <= end]
    
    med_y.append(np.median(bin_y_val)) 
    med_x.append(np.median(bin_x_val))

```
Here is a visualization of the spline mapped to the skeleton:

```python
fig, ax = plt.subplots()
plt.plot(merged_spline[:,0], merged_spline[:,1], 'y.')
ax.yaxis.set_inverted(True)
```
![alt text](/demo/spline.png)






